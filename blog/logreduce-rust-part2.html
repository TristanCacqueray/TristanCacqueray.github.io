<!DOCTYPE html>
<!-- TODO: Main navigation links (Home, index, tags, ...) --><!-- DoNotFormat -->
<!-- DoNotFormat -->

<html lang='en'>

<head>
  <meta charset='UTF-8' />
  <meta name='viewport' content='width=device-width, initial-scale=1' />
  <title>
    Implementing logreduce nearest neighbors model in Rust â€“ Tristan's Zettelkasten
  </title>
  
    
      <meta property='og:description' content='This post was initially published on the Software Factory blog: https://www.softwarefactory-project.io/implementing-logreduce-nearest-neighbors-model-in-rust.html' />
      <meta property='og:site_name' content="Tristan's Zettelkasten" />
      <meta property='og:image' content />
      <meta property='og:type' content='website' />
      <meta property='og:title' content='Implementing logreduce nearest neighbors model in Rust' />
    
    
      <base href='/' />
      <link href='static/favicon.jpeg' rel='icon' />
    
    <!-- highlight.js -->
<link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/hybrid.min.css' />
<script src='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js'></script>
<!-- Include languages that Emanote itself uses -->
<script src='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/languages/haskell.min.js'></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/languages/nix.min.js'></script>
<script>hljs.highlightAll();</script>


<!-- mermaid.js --><script type='module'>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: false });
  mermaid.init(undefined,document.querySelectorAll(".mermaid"));
</script>

<script>
window.MathJax = {
  startup: {
    ready: () => {MathJax.startup.defaultReady();}
  }
};
</script>
<script async id='MathJax-script' src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'></script>

  
  <link href='tailwind.css?instanceId=1488301e-d6e9-4a80-8c88-440a0bdbc140' rel='stylesheet' type='text/css' />

  <style>
    /* Heist error element */
    strong.error {
      color: lightcoral;
      font-size: 90%;
      font-family: monospace;
    }

    /* External link icon */
    a[data-linkicon=""]::after {
      content: ""
    }

    a[data-linkicon=none]::after {
      content: ""
    }

    a[data-linkicon="external"]::after {
      content: url('data:image/svg+xml,\
      <svg xmlns="http://www.w3.org/2000/svg" height="0.7em" viewBox="0 0 20 20"> \
        <g style="stroke:gray;stroke-width:1"> \
          <line x1="5" y1="5" x2="5" y2="14" /> \
          <line x1="14" y1="9" x2="14" y2="14" /> \
          <line x1="5" y1="14" x2="14" y2="14" /> \
          <line x1="5" y1="5" x2="9" y2="5"  /> \
          <line x1="10" y1="2" x2="17" y2="2"  /> \
          <line x1="17" y1="2" x2="17" y2="9" /> \
          <line x1="10" y1="9" x2="17" y2="2" style="stroke-width:1.0" /> \
        </g> \
      </svg>');
    }

    a[data-linkicon="external"][href^="mailto:"]::after {
      content: url('data:image/svg+xml,\
        <svg \
          xmlns="http://www.w3.org/2000/svg" \
          height="0.7em" \
          fill="none" \
          viewBox="0 0 24 24" \
          stroke="gray" \
          stroke-width="2"> \
          <path \
            stroke-linecap="round" \
            stroke-linejoin="round" \
            d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" /> \
        </svg>');
    }
  </style>
  <!-- What goes in this file will appear on near the end of <head>--><link rel='preload' href='_emanote-static/fonts/Work_Sans/WorkSans-VariableFont_wght.ttf' as='font' type='font/ttf' crossorigin />

<style>
  @font-face {
    font-family: 'WorkSans';
    /* FIXME: This ought to be: ${ema:emanoteStaticLayerUrl}/fonts/Work_Sans/WorkSans-VariableFont_wght.ttf */
    src: url(_emanote-static/fonts/Work_Sans/WorkSans-VariableFont_wght.ttf) format("truetype");
    font-display: swap;
  }

  body {
    font-family: 'WorkSans', sans-serif;
    font-variation-settings: 'wght' 350;
  }

  a.mavenLinkBold {
    font-variation-settings: 'wght' 400;
  }

  strong {
    font-variation-settings: 'wght' 500;
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6,
  header,
  .header-font {
    font-family: 'WorkSans', sans-serif;
  }

  h1 {
    font-variation-settings: 'wght' 500;
  }

  h2 {
    font-variation-settings: 'wght' 400;
  }

  h3 {
    font-variation-settings: 'wght' 300;
  }
</style>


  
    <link rel='stylesheet' href='_emanote-static/inverted-tree.css' />
  
  <link rel='stylesheet' href='_emanote-static/stork/flat.css' />
<!-- Custom Stork-search styling for Emanote -->
<style>
  #stork-search-container {
    z-index: 1000;
    background-color: rgb(15 23 42/.8);
  }

  .stork-overflow-hidden-important {
    overflow: hidden !important;
  }
</style>


<script src='_emanote-static/stork/stork.js'></script>

  
    <script data-emanote-base-url='/'>
      window.emanote = {};
      window.emanote.stork = {
        searchShown: false,
        toggleSearch: function () {
          document.getElementById('stork-search-container').classList.toggle('hidden');
          window.emanote.stork.searchShown = document.body.classList.toggle('stork-overflow-hidden-important');
          if (window.emanote.stork.searchShown) {
            document.getElementById('stork-search-input').focus();
          }
        },
        clearSearch: function () {
          document.getElementById('stork-search-container').classList.add('hidden');
          document.body.classList.remove('stork-overflow-hidden-important');
          window.emanote.stork.searchShown = false;
        },

        init: function () {
          const indexName = 'emanote-search'; // used to match input[data-stork] attribute value
          const baseUrl = document.currentScript.getAttribute('data-emanote-base-url') || '/';
          const indexUrl = baseUrl + '-/stork.st';
          if (document.readyState !== 'complete') {
            window.addEventListener('load', function () {
              stork.initialize(baseUrl + '_emanote-static/stork/stork.wasm');
              stork.register(indexName, indexUrl);
            });

            document.addEventListener('keydown', event => {
              if (window.emanote.stork.searchShown && event.key === 'Escape') {
                window.emanote.stork.clearSearch();
                event.preventDefault();
              } else if ((event.key == 'k' || event.key == 'K') && (event.ctrlKey || event.metaKey)) {
                window.emanote.stork.toggleSearch();
                event.preventDefault();
              }
            });
          } else {
            // Override existing on Ema's hot-reload
            stork.register(indexName, indexUrl, { forceOverwrite: true });
          }
        }
      };

      window.emanote.stork.init();
    </script>
  

</head>

<!-- DoNotFormat -->



<!-- DoNotFormat -->

<body class='overflow-y-scroll bg-gray-400'>
  
    <div class='container mx-auto max-w-screen-lg'>
      <div class='mt-2 md:mt-4'>
        <!-- DoNotFormat -->
<!-- DoNotFormat -->

<nav id='uptree' class='flipped tree' style='transform-origin: 50%;'>
  <ul class='root'>
    <li>
      
        <ul>
          
            <li>

  <div class='text-gray-900 forest-link'>
    <a href='blog'>
      Blog
    </a>
  </div>

  
    <ul>
      
        <li>

  <div class='text-gray-900 forest-link'>
    <a href=''>
      Tristan de Cacqueray
    </a>
  </div>

  
</li>
      
    </ul>
  
</li>
          
        </ul>
      
    </li>
  </ul>
</nav>

        <div class='relative md:shadow-2xl md:mb-8'>

          <div class='absolute -top-6 right-1 md:right-0 flex flex-row items-center justify-center'>
            <a title='Search (Ctrl+K)' class='cursor-pointer' onclick='window.emanote.stork.toggleSearch()'>
              <svg xmlns='http://www.w3.org/2000/svg' style='width: 1rem;' class='hover:text-blue-700' f
 fill='none' viewBox='0 0 24 24' stroke='currentColor' stroke-width='2'>
  <path stroke-linecap='round' stroke-linejoin='round' d='M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z'></path>
</svg>
            </a>
          </div>
          <div class='flex-1 w-full overflow-x-auto bg-white'>
            <main class='px-4 py-4'>
              <h1 class='flex items-end justify-center mb-4 p-3 bg-blue-100 text-5xl font-extrabold text-black rounded'>
  <a class='z-40 tracking-tighter '>
    Implementing logreduce nearest neighbors model in Rust
  </a>
</h1>
              <article class='overflow-auto'>
  <!-- What goes in this file will appear on top of note body-->
  
    <blockquote class='py-0.5 px-4 mb-3 italic border-l-4 bg-gray-50 text-gray-600 border-gray-400 quote'>
      
    <p class='mb-3'>
      This post was initially published on the Software Factory blog: <a href='https://www.softwarefactory-project.io/implementing-logreduce-nearest-neighbors-model-in-rust.html' class='text-blue-600 hover:underline' data-linkicon='external' target='_blank' rel='noopener'>https://www.softwarefactory-project.io/implementing-logreduce-nearest-neighbors-model-in-rust.html</a>
    </p>
  
    </blockquote>
  
    <p class='mb-3'>
      This article is a follow-up on the previous post about <a href='blog/logreduce-rust-part1' class='text-blue-600 mavenLinkBold hover:underline' data-wikilink-type='WikiLinkNormal'>Improving logreduce with Rust</a>. With the new tokenizer in place, the next step is to implement the nearest neighbors model.
    </p>
  
    <p class='mb-3'>
      In this post you will learn the following about the core algorithm of logreduce:
    </p>
  
    <ul class='my-3 ml-6 space-y-1 list-disc'>
      
        <li>
          Why vectorization is necessary.
        </li>
      
        <li>
          Cosine similarity.
        </li>
      
        <li>
          How to compute the distances between two matrices.
        </li>
      
    </ul>
  <h2 id='problem-statement' class='inline-block mt-6 mb-4 text-4xl font-bold text-gray-700 border-b-2'>Problem statement</h2>
    <p class='mb-3'>
      Given two log files: a baseline and a target, the goal is to extract useful information from the target by finding the log lines that don't occur in the baseline. For example, here is a simple solution implementation:
    </p>
  <div class='py-0.5 mb-3 text-sm'><pre><code class='python language-python'>for target_log in targets:
    for baseline_log in baselines:
        if difference(target_log, baseline_log) &gt; threshold:
            print(target_log)
            break</code></pre></div>
    <blockquote class='py-0.5 px-4 mb-3 italic border-l-4 bg-gray-50 text-gray-600 border-gray-400 quote'>
      
    <p class='mb-3'>
      The log line order is not considered because it is often not deterministic.
    </p>
  
    </blockquote>
  
    <p class='mb-3'>
      The difference test can be implemented using <a href='https://en.wikipedia.org/wiki/Levenshtein_distance' class='text-blue-600 hover:underline' data-linkicon='external' target='_blank' rel='noopener'>Levenshtein distance</a> so that small variations in the logs can be ignored. Unfortunately, this solution is not efficient. Assuming it takes 20Âµsec to compare two lines, then processing 512 targets with 20_000 baselines would take more than 3 minutes.
    </p>
  
    <p class='mb-3'>
      The next sections introduce a technique to improve the performance by converting the log lines into numerical vectors.
    </p>
  <h2 id='the-hashing-trick' class='inline-block mt-6 mb-4 text-4xl font-bold text-gray-700 border-b-2'>The Hashing Trick</h2>
    <p class='mb-3'>
      Instead of working with the raw text, the log lines can be converted into numerical vectors using <a href='https://en.wikipedia.org/wiki/Feature_hashing' class='text-blue-600 hover:underline' data-linkicon='external' target='_blank' rel='noopener'>the hashing trick</a>. The <a href='https://scikit-learn.org/' class='text-blue-600 hover:underline' data-linkicon='external' target='_blank' rel='noopener'>scikit-learn</a> library provides such technique with the HashingVectorizer object:
    </p>
  <div class='py-0.5 mb-3 text-sm'><pre><code class='python language-python'>&gt;&gt;&gt; from sklearn.feature_extraction.text import HashingVectorizer
&gt;&gt;&gt; vectorizer = HashingVectorizer()
&gt;&gt;&gt; baselines = vectorizer.fit_transform(["log line content"])
&lt;1x1048576 sparse matrix of type '&lt;class 'numpy.float64'&gt;'
    with 3 stored elements in Compressed Sparse Row format&gt;
&gt;&gt;&gt; (baselines.indices, baselines.data)
(array([325140, 377854, 846328], dtype=int32), array([0.57735027, 0.57735027, 0.57735027]))</code></pre></div>
    <p class='mb-3'>
      As you can see, the result is a sparse vector of about 1 million columns where the indices are the word's hash value modulo the number of features. The vector is defined with the Compressed Sparse Row (CSR) format, and fortunately there is an existing Rust library named <a href='https://docs.rs/sprs' class='text-blue-600 hover:underline' data-linkicon='external' target='_blank' rel='noopener'>sprs</a> which provides an equivalent implementation. Here is how this vectorizer can be implemented:
    </p>
  <div class='py-0.5 mb-3 text-sm'><pre><code class='rust language-rust'>use sprs::*;
use itertools::Itertools;
use fxhash::hash32;

/// A type alias for sprs vector
type SparseVec = CsVecBase&lt;Vec&lt;usize&gt;, Vec&lt;f64&gt;, f64&gt;;
const SIZE: usize = 260000;

/// Word based hashing vectorizer
pub fn vectorize(line: &str) -&gt; SparseVec {
    let (keys, values) = line
        .split(' ')
        .map(|word| {
            let hash = hash32(word);
            // alternate sign
            let sign = if hash &gt;= 2147483648 { 1.0 } else { -1.0 };
            ((hash as usize) % SIZE, sign)
        })
        .sorted_by(|a, b| Ord::cmp(&a.0, &b.0))
        .dedup_by(|a, b| a.0 == b.0)
        .unzip();
    CsVec::new(SIZE, keys, values)
}</code></pre></div>
    <blockquote class='py-0.5 px-4 mb-3 italic border-l-4 bg-gray-50 text-gray-600 border-gray-400 quote'>
      
    <p class='mb-3'>
      Word order is not considered when using this trick.
    </p>
  
    </blockquote>
  
    <p class='mb-3'>
      The next section introduces how to compare such numerical vectors.
    </p>
  <h2 id='cosine-similarity' class='inline-block mt-6 mb-4 text-4xl font-bold text-gray-700 border-b-2'>Cosine Similarity</h2>
    <p class='mb-3'>
      In data analysis, the <a href='https://en.wikipedia.org/wiki/Cosine_similarity' class='text-blue-600 hover:underline' data-linkicon='external' target='_blank' rel='noopener'>cosine similarity</a> is a measure of similarity between two sequences of numbers. By applying the text book formula, the following function returns a number between 0 and 1, where 1 means the vectors are similar, and 0 means they are different.
    </p>
  <div class='py-0.5 mb-3 text-sm'><pre><code class='rust language-rust'>pub fn cosine_similarity(a: &SparseVec, b: &SparseVec) -&gt; f64 {
    a.dot(b) / (a.l2_norm() * b.l2_norm())
}</code></pre></div>
    <p class='mb-3'>
      This measure works well with sparse vectors because only the non zero values are used. Even though this code performs almost as fast as the current logreduce's implementation, it is inefficient because the lines are still compared one by one.
    </p>
  
    <p class='mb-3'>
      The next section introduces how to compute the cosine similarity between two lists of vectors using matrices.
    </p>
  <h2 id='pairwise-distance' class='inline-block mt-6 mb-4 text-4xl font-bold text-gray-700 border-b-2'>Pairwise Distance</h2>
    <p class='mb-3'>
      The usual nearest neighbors algorithms do not work with sparse vectors. Even though the goal is to find the nearest neighbors, the <a href='https://scikit-learn.org/' class='text-blue-600 hover:underline' data-linkicon='external' target='_blank' rel='noopener'>scikit-learn</a> model uses a bruteforce algorithm when working with sparse data:
    </p>
  <div class='py-0.5 mb-3 text-sm'><pre><code class='python language-python'>&gt;&gt;&gt; from sklearn.metrics.pairwise import cosine_distances
&gt;&gt;&gt; targets = vectorizer.fit_transform(["another line content", "a traceback"])
&gt;&gt;&gt; cosine_distances(baselines, targets)
array([[0.33333333, 1.        ]])</code></pre></div>
    <p class='mb-3'>
      As you can see, the result is a list of distances between the baselines and the targets. 0.33 indicates that the first target is near the baseline, and the second target is the farthest: its distance is 1. This technique is very fast because it leverages an optimized matrix multiplication operation. Here is how this function can be implemented:
    </p>
  <div class='py-0.5 mb-3 text-sm'><pre><code class='rust language-rust'>pub type FeaturesMatrix = CsMatBase&lt;f64, usize, Vec&lt;usize&gt;, Vec&lt;usize&gt;, Vec&lt;f64&gt;&gt;;

/// Create a normalized matrix
pub fn create_mat(vectors: &[SparseVec]) -&gt; FeaturesMatrix {
    let mut mat = TriMat::new((vectors.len(), SIZE));
    for (row, vector) in vectors.iter().enumerate() {
        let l2_norm = vector.l2_norm();
        for (col, val) in vector.iter() {
            mat.add_triplet(row, col, *val / l2_norm);
        }
    }
    mat.to_csr()
}

/// Compute the smallest cosine distance between two normalized matrix. The rhs must be transposed.
pub fn search(baselines: &FeaturesMatrix, targets: &FeaturesMatrix) -&gt; Vec&lt;f64&gt; {
    let mut result = vec![1.0; targets.cols()];
    let distances_mat = baselines * targets;
    distances_mat
        .iter()
        .for_each(|(v, (_, col))| result[col] = (1.0 - v).min(result[col]));
    result
}</code></pre></div>
    <p class='mb-3'>
      The trick is to perform the l2 normalizations before computing the cross product of the two matrices. This yields a new matrix that contains the distances between each row.
    </p>
  
    <p class='mb-3'>
      The <a href='https://github.com/logreduce/logreduce-rust/blob/main/python/benches/bench-index.py' class='text-blue-600 hover:underline' data-linkicon='external' target='_blank' rel='noopener'>benchmark</a> shows that this new implementation performs almost four times faster, even with the overhead of converting Python and Rust types. More importantly, running the full toolchain confirmed it produces the exact same results, the math worked, and that was a big relief!
    </p>
  <h2 id='conclusion' class='inline-block mt-6 mb-4 text-4xl font-bold text-gray-700 border-b-2'>Conclusion</h2>
    <p class='mb-3'>
      Thanks to the <a href='https://docs.rs/sprs' class='text-blue-600 hover:underline' data-linkicon='external' target='_blank' rel='noopener'>sprs</a> library, I was able to implement all the <a href='https://scikit-learn.org/' class='text-blue-600 hover:underline' data-linkicon='external' target='_blank' rel='noopener'>scikit-learn</a> features used in logreduce. I wanted to use a higher level library such as <a href='https://rust-ml.github.io/linfa/' class='text-blue-600 hover:underline' data-linkicon='external' target='_blank' rel='noopener'>linfa</a>, but as suggested in this <a href='https://github.com/rust-ml/linfa/issues/200' class='text-blue-600 hover:underline' data-linkicon='external' target='_blank' rel='noopener'>issue</a>, the implementation is so simple that it can easily be done from scratch.
    </p>
  
    <p class='mb-3'>
      This new code is simpler and more portable, and it's great to see Rust out-performing Python. Perhaps it is possible to use a more efficient algorithm with dense vectors. For now I am satisfied with the current result. You can find the complete code in the index library of <a href='https://github.com/logreduce/logreduce-rust' class='text-blue-600 hover:underline' data-linkicon='external' target='_blank' rel='noopener'>logreduce-rust</a>
    </p>
  
    <p class='mb-3'>
      It seems like the next step is to implement a log files iterator and build the html report. That way the new implementation could be used standalone.
    </p>
  
    <p class='mb-3'>
      I always welcome feedback, and if you would like to contribute, please join the <a href='https://matrix.to/#/#logreduce:matrix.org' class='text-blue-600 hover:underline' data-linkicon='external' target='_blank' rel='noopener'>logreduce:matrix.org</a> chat room.
    </p>
  
    <p class='mb-3'>
      Thank you for reading!
    </p>
  

  <!-- What goes in this file will appear below the note body-->
</article>
              <div class='flex flex-col lg:flex-row lg:space-x-2'>
                
                
  <div class='flex-1 p-4 mt-8 bg-gray-100 rounded'>
    <header class='mb-2 text-xl font-semibold text-gray-500'>Links to this page</header>
    <ul class='space-y-1'>
      
        <li>
          <a class='text-blue-600 mavenLinkBold hover:bg-blue-50' href='blog/logreduce-rust-part3'>
            Introducing the BytesLines iterator
          </a>
          
            <div class='mb-4 overflow-auto text-sm text-gray-500'>
  
    <div class='pl-2 mt-2 border-l-2 border-blue-200 hover:border-blue-500'>
      <div>Part2: <a href='blog/logreduce-rust-part2' class='text-gray-600 font-bold hover:bg-gray-50' data-wikilink-type='WikiLinkNormal'>Implementing logreduce nearest neighbors model in Rust</a></div>
    </div>
  
</div>
          
        </li>
      
        <li>
          <a class='text-blue-600 mavenLinkBold hover:bg-blue-50' href='blog/logreduce-rust-part4'>
            Completing the first release of logreduce-rust
          </a>
          
            <div class='mb-4 overflow-auto text-sm text-gray-500'>
  
    <div class='pl-2 mt-2 border-l-2 border-blue-200 hover:border-blue-500'>
      <div>Part2: <a href='blog/logreduce-rust-part2' class='text-gray-600 font-bold hover:bg-gray-50' data-wikilink-type='WikiLinkNormal'>Implementing logreduce nearest neighbors model in Rust</a></div>
    </div>
  
</div>
          
        </li>
      
    </ul>
  </div>

              </div>
              
  <section class='flex flex-wrap items-end justify-center my-4 space-x-2 space-y-2 font-mono text-sm'>
    
      <!-- FIXME: The use of -/tags is wrong, because we should use routeUrl using Ema's encoder
        Perhaps Emanote should inject tagMetas with urls.
      -->
      <a title='Tag' class='px-1 bg-gray-100 rounded hover:bg-gray-50 hover:text-blue-500' href='-/tags/blog'>
        <!-- DoNotFormat -->
        #blog
        <!-- DoNotFormat -->
      </a>
    
      <!-- FIXME: The use of -/tags is wrong, because we should use routeUrl using Ema's encoder
        Perhaps Emanote should inject tagMetas with urls.
      -->
      <a title='Tag' class='px-1 bg-gray-100 rounded hover:bg-gray-50 hover:text-blue-500' href='-/tags/rust'>
        <!-- DoNotFormat -->
        #rust
        <!-- DoNotFormat -->
      </a>
    
      <!-- FIXME: The use of -/tags is wrong, because we should use routeUrl using Ema's encoder
        Perhaps Emanote should inject tagMetas with urls.
      -->
      <a title='Tag' class='px-1 bg-gray-100 rounded hover:bg-gray-50 hover:text-blue-500' href='-/tags/logreduce'>
        <!-- DoNotFormat -->
        #logreduce
        <!-- DoNotFormat -->
      </a>
    
  </section>
  <div class='flex items-center justify-center mt-2'>
    <a class='text-gray-300 hover:text-blue-600 text-sm' title='Edit this page on GitHub' href='https://github.com/TristanCacqueray/TristanCacqueray.github.io/edit/main/docs/blog/logreduce-rust-part2.md'>
      <svg xmlns='http://www.w3.org/2000/svg' class='h-6 w-6' fill='none' viewBox='0 0 24 24' stroke='currentColor'>
        <path stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z'></path>
      </svg>
    </a>
    <p class='text-sm text-gray-600 mx-2'>
      This work is licensed under a <a class='hover:underline' href='http://creativecommons.org/licenses/by/4.0/'>Creative Commons Attribution 4.0 International License</a>
    </p>
  </div>


              <!-- What goes in this file will at the very end of the main div -->
            </main>
          </div>
        </div>
        <footer class='flex items-center justify-center mt-2 mb-8 space-x-4 text-center text-gray-800'>
  
  <div>
    <a href='' title='Go to Home page'>
      <svg xmlns='http://www.w3.org/2000/svg' class='w-6 h-6 hover:text-blue-700' fill='none' viewBox='0 0 24 24' stroke='currentColor'>
        <path stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6'></path>
      </svg>
    </a>
  </div>
  <div>
    <a href='-/all' title='View Index'>
      <svg class='w-6 h-6 hover:text-blue-700' fill='none' stroke='currentColor' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'>
        <path stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4'>
        </path>
      </svg>
    </a>
  </div>
  <div>
    <a href='-/tags' title='View tags'>
      <svg class='w-6 h-6 hover:text-blue-700' fill='none' stroke='currentColor' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'>
        <path stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z'>
        </path>
      </svg>
    </a>
  </div>
  <div>
    <a href='https://emanote.srid.ca' target='_blank' title='Generated by Emanote 1.0.1.7'>
      <img class='w-6 h-6 hover:text-blue-700' src='_emanote-static/emanote-logo.svg' />
    </a>
  </div>
</footer>

      </div>
    </div>
  
  <div id='stork-search-container' class='hidden fixed w-screen h-screen inset-0 backdrop-filter backdrop-blur-sm'>
  <div class='fixed w-screen h-screen inset-0' onclick='window.emanote.stork.toggleSearch()'></div>

  <div class='container mx-auto p-10 mt-10'>
    <div class='stork-wrapper-flat container mx-auto'>
      <input id='stork-search-input' data-stork='emanote-search' class='stork-input' placeholder='Search (Ctrl+K) ...' />
      <div data-stork='emanote-search-output' class='stork-output'></div>
    </div>
  </div>
</div>
  
    
  
</body>

</html>